@{%
const tokens = require('./tokens.js')
const symbolTable = {}
%}

@lexer tokens

program 
    -> statement:? {% id %}
    | funclist:? {% id %}

funclist 
    -> funcdef funclist {% data => data.join("") %}
    | funcdef {% id %}

funcdef -> %def _ identifier _ %lparan _ paramlist _ %rparan _ NL _ %lbrace _ NL _ statelist _ NL _ %rbrace _
    {% data => {
        const returnData = []
        data.forEach(function(token) {
            if (typeof token.type === "string") {
                returnData.push(token.type)
            } else if(Array.isArray(token)) {
                returnData.push(...token)
            } else {
                returnData.push(token)
            }
        })
        return returnData
    } %}

paramlist 
    -> %type_keyword _ identifier _ %comma _ paramlist 
    {% data => {
        data[0] = data[0].value
        data[4] = data[4].value
        if(Array.isArray(data[6])) {
            data.push(...data[6])
            data.splice(6, 1)
        }
        return data
    } %}
    | %type_keyword _ identifier:? 
    {% data => {
        data[0] = data[0].value
        return data
    } %}

statelist -> statement statelist:? 
    {% id %}

statement ->
     vardecl %semicolon NL {% id %}
     | atribstat %semicolon NL {% id %}
     | printstat %semicolon NL {% id %}
     | readstat %semicolon NL {% id %}
     | returnstat %semicolon NL {% id %}
     | ifstat {% id %}
     | forstat {% id %}
     | %lbrace statelist %rbrace {% id %}
     | "break" %semicolon NL {% id %}
     | %semicolon NL {% id %}

vardecl 
    -> %type_keyword _ %identifier _ (%lbracket %digit %rbracket):* {% id %}
    | %type_keyword _ atribstat {% id %}

atribstat -> lvalue _ %equals _ ( expression | allocexpression | funccall)

funccall -> identifier %lparan paramlistcall %rparan

paramlistcall -> (identifier %comma paramlistcall | identifier):?

printstat -> "print" expression

readstat -> "read" lvalue

returnstat -> "return"

ifstat -> "if" %lparan expression %rparan statement ("else" statement):?

forstat -> "for" %lparan atribstat %semicolon expression %semicolon atribstat %rparan
statement

allocexpression -> "new" %type_keyword (%lbracket numexpression %rbracket):+

expression -> numexpression (( %minor | %major | %minor_or_equal | %major_or_equal | %equal_equal | %not_equal ) numexpression):?

numexpression -> term ((%plus | %minus) term):*

term -> unaryexpr (( %times | %divide | %percentage) unaryexpr):*

unaryexpr -> ((%plus | %minus)):? factor

factor 
    -> %number {% id %}
    | %digit {% id %}
    | %string {% id %}
    | null {% () => null %}
    | lvalue {% id %}
    | %lparan numexpression %rparan 

lvalue -> identifier ( %lbracket numexpression %rbracket ):* {% id %}

_ -> %whitespace:* {% () => "whitespace" %}

NL -> %NL:* {% () => "newline" %}

identifier -> %identifier 
    {% 
    data => {
        const identifierInfo = data[0]
        symbolTable[identifierInfo.value] = data[0]
        return identifierInfo.type
    } 
    %}